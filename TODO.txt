# TODO

## Monitoring

Maybe there's a "thespian runtime" that handles monitoring all actors and
ensuring the various invariants.

Want:

* Build monitor support similar to Erlang's
  * something like link so we can build supervisors
  * Health monitoring to kill "stuck" actors
* Useful runtime metrics
  * Expvar integration?
  * channel utilization
  * actor utilization

## Communication

Make channels ("connections"?) a first-class type, that must be provided when
creating a new actor instance.

Want:

* Abstraction for channels, too (mailbox)
* Some way to support multiple consumers (e.g., multiple demuxes)
* Flexible polling (so, ignore some messages in some modes)

## Tasks

* a way to test this with unit tests and not a program
* generate from thespian.yml (or toml or something) in the package dir, to
  avoid parsing go at all
  * actor mailboxes should give kind, (for message-based) mailbox type name, message type
    * some mailbox type names are predefined (e.g., Timer)
  * (can't always refer to types in other packages as they may not include .yml)

Misc:
* copy the private struct in `spawn` so that callers *cannot* maintain a
  reference to it
* move some types to internal/
* allow mailbox types not in the same package (still need info on their type)
* Receiver -> Rx, Sender -> Tx

Later:
* allow build flags for generation
* use something with fewer deps than cobra (gRPC?!?)

# Example

type Foo struct {
	name    string
	samples []int
}

/* user:
FooMailbox:
  kind: simple
  messageType: Foo
*/

type FooMailbox struct { // gen
}

type FooSender struct { // gen
	c chan<- Foo
}

type FooReceiver struct { // gen
	c <-chan Foo
}

type harrisonFord struct { // user
	fooMailbox FooReceiver
	names      []string
}

type harrisonFordSpawner struct { // gen
	fooMailbox FooMailbox
	names      []string
}

func (s harrisonFordSpawner) spawn(rt *Runtime) *HarrisonFord { // gen
	return nil // automatically creates a private harrisonFord and a HarrisonFord
}

func NewHarrisonFord(rt *Runtime, names []string) *HarrisonFord {
	return harrisonFordSpawner{
		names: names,
		// can set xxMailbox here if multi-consumer is desired
	}.spawn(rt)
}

func (a *harrisonFord) HandleFoo(m Foo) { // user
	// ...
}

func (a *harrisonFord) loop() { // gen
	for {
		select {
		// generated snippet:
		case m := <-a.fooMailbox.c:
			a.HandleFoo(m)
			// ...
		}
	}
}

type HarrisonFord struct { // gen
	fooMailbox FooSender
}

func (a *HarrisonFord) Foo(m Foo) { // gen
	a.fooMailbox.c <- m
}
