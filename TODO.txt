# TODO

## Monitoring

Maybe there's a "thespian runtime" that handles monitoring all actors and
ensuring the various invariants.

Want:

* Build monitor support similar to Erlang's
  * something like link so we can build supervisors
  * Health monitoring to kill "stuck" actors
* Useful runtime metrics
  * Expvar integration?
  * channel utilization
  * actor utilization

## Communication

Make channels ("mailboxes") a first-class type, that must be provided when
creating a new actor instance.

Want:

* Abstraction for channels, too (mailbox)
* Some way to support multiple consumers (e.g., multiple demuxes)
* Flexible polling (so, ignore some messages in some modes)

## Tasks

* a way to test this with unit tests and not a program

Misc:
* move some types to internal/
* clean up how mailbox types are specified; maybe parse `<path>.FooMailbox`?

Later:
* allow build flags for generation

### example

package thespian

type HarrisonFordBuilder struct { //gen
	harrisonFord

	frob FooMailbox
	bing BarMailbox
}

type HarrisonFordTx struct { // gen
	frob FooTx
	bing BarTx
}

func (tx *HarrisonFordTx) Frob(m Foo) {
	// ...
}

func (tx *HarrisonFordTx) Bing(m Bar) {
	// ...
}

type harrisonFordRx struct { // gen
	frob FooRx
	bing FooRx
}

type harrisonFord struct { // user
	tx         *HarrisonFordTx
	rx         *HarrisonFordRx
	userField1 string
	userField2 string
}

func (hf *harrisonFord) handleFrob(m Foo) {
	hf.rx.frob.Disable()
	hf.tx.Bing(Bar{})
}

func (hf *harrisonFord) handleBing(m Bar) {
}
