// code generated by thespian; DO NOT EDIT

package gentest

import (
	"github.com/djmitche/thespian"
	import1 "github.com/djmitche/thespian/mailbox"
)

// AggregatorBuilder is used to buidl new Aggregator actors.
type AggregatorBuilder struct {
	aggregator

	incr StringMailbox
}

func (bldr AggregatorBuilder) spawn(rt *thespian.Runtime) *AggregatorTx {
	reg := rt.Register()

	bldr.incr.ApplyDefaults()

	rx := &AggregatorRx{
		id:         reg.ID,
		stopChan:   reg.StopChan,
		healthChan: reg.HealthChan,
		flush:      import1.NewTickerRx(),
		incr:       bldr.incr.Rx(),
	}

	tx := &AggregatorTx{
		stopChan: reg.StopChan,

		incr: bldr.incr.Tx(),
	}

	// copy to a new aggregator instance
	pvt := bldr.aggregator
	pvt.rt = rt
	pvt.rx = rx
	pvt.tx = tx

	go pvt.loop()
	return tx
}

// AggregatorRx contains the Rx sides of the mailboxes, for access from the
// Aggregator implementation.
type AggregatorRx struct {
	id         uint64
	stopChan   <-chan struct{}
	healthChan <-chan struct{}
	flush      import1.TickerRx
	incr       StringRx
}

// AggregatorTx is the public handle for Aggregator actors.
type AggregatorTx struct {
	stopChan chan<- struct{}

	incr StringTx
}

// Stop sends a message to stop the actor.  This does not wait until
// the actor has stopped.
func (a *AggregatorTx) Stop() {
	select {
	case a.stopChan <- struct{}{}:
	default:
	}
}

// Incr sends to the actor's incr mailbox.
func (tx *AggregatorTx) Incr(m string) {
	tx.incr.C <- m
}

func (a *aggregator) loop() {
	rx := a.rx
	defer func() {
		rx.flush.Close()

		a.rt.ActorStopped(a.rx.id)
	}()
	a.handleStart()
	for {
		select {
		case <-rx.healthChan: // TODO
			// nothing to do
		case <-rx.stopChan:
			a.handleStop()
			return
		case t := <-rx.flush.Chan():
			a.handleFlush(t)
		case m := <-rx.incr.C:
			a.handleIncr(m)
		}
	}
}
