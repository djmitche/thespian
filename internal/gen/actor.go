package gen

import (
	"fmt"
	"sort"
	"text/template"
)

var (
	actorTemplate *template.Template
)

type ActorGenerator struct {
	ThisPackage   string
	ActorTypeBase string
	Mailboxes     []MailboxGenerator
	Imports       []string
}

func NewActorGenerator(pkg, name string, yml ActorYml) *ActorGenerator {
	gen := &ActorGenerator{
		ThisPackage:   pkg,
		ActorTypeBase: name,
		Mailboxes:     nil,
		Imports:       []string{fmt.Sprintf(`"%s"`, thespianPackage)},
	}

	// generate a stable order for mailbox fields
	mbFields := []string{}
	for fieldName := range yml.Mailboxes {
		mbFields = append(mbFields, fieldName)
	}
	sort.Strings(mbFields)

	// imports are named `import1`, `import2`, .., so keep those
	// names handy, mapping package -> name
	importNames := map[string]string{
		thespianPackage: "thespian",
	}

	for _, fieldName := range mbFields {
		actorMailboxYml := yml.Mailboxes[fieldName]
		// TODO: strip a "Mailbox" prefix here
		typeQual := ""
		if actorMailboxYml.Import != "" {
			var shortName string
			shortName, found := importNames[actorMailboxYml.Import]
			if !found {
				shortName = fmt.Sprintf("import%d", len(gen.Imports))
				gen.Imports = append(gen.Imports,
					fmt.Sprintf(`%s "%s"`, shortName, actorMailboxYml.Import))
				importNames[actorMailboxYml.Import] = shortName
			}
			typeQual = fmt.Sprintf("%s.", shortName)
		}
		gen.Mailboxes = append(gen.Mailboxes,
			NewMailboxGeneratorForActor(pkg, name, fieldName, typeQual, actorMailboxYml))
	}

	return gen
}

func (g *ActorGenerator) GenerateGo(out *formatter) {
	out.executeTemplate(getTemplate(
		"actor_gen", `
{{- $base := printf "%sBase" .ActorTypeBase | private }}
{{- $builder := printf "%sBuilder" .ActorTypeBase | public }}
{{- $tx := printf "%sTx" .ActorTypeBase | public }}
{{- $rx := printf "%sRx" .ActorTypeBase | public }}
{{- $private := .ActorTypeBase | private }}
// code generated by thespian; DO NOT EDIT

package {{.ThisPackage}}

import (
	{{- range .Imports }}
	{{ . }}
	{{- end }}
)

// {{$base}} is embedded in the private actor struct and contains
// common fields as well as default method implementations
type {{$base}} struct {
	rt *thespian.Runtime
	tx *{{$tx}}
	rx *{{$rx}}
}

// handleStart is called when the actor starts.  The default implementation
// does nothing, but users may implement this method to perform startup.
func (a *{{$base}}) handleStart() {}

// handleStop is called when the actor stops cleanly.  The default
// implementation does nothing, but users may implement this method to perform
// cleanup.
func (a *{{$base}}) handleStop() {}

// handleSuperEvent is called for supervisory events.  Actors which do not
// supervise need not implement this method.
func (a *{{$base}}) handleSuperEvent(ev thespian.SuperEvent) {}

// {{$builder}} is used to build new {{.ActorTypeBase}} actors.
type {{$builder}} struct {
	{{$private}}

	{{- range .Mailboxes }}
	{{ .ActorBuilderStructDecl }}
	{{- end }}
}

func (bldr {{$builder}}) spawn(rt *thespian.Runtime) *{{$tx}} {
	reg := rt.Register()

	{{- range .Mailboxes }}
	{{ .ActorSpawnSetupClause }}
	{{- end }}

	rx := &{{$rx}}{
		id: reg.ID,
		rt: rt,
		stopChan: reg.StopChan,
		superChan: reg.SuperChan,
		healthChan: reg.HealthChan,
		{{- range .Mailboxes }}
		{{ .ActorRxInitializer }}
		{{- end }}
	}

	tx := &{{$tx}}{
		ID: reg.ID,
		stopChan: reg.StopChan,
		{{- range .Mailboxes }}
		{{ .ActorTxInitializer }}
		{{- end }}
	}
	
	// copy to a new {{$private}} instance
	pvt := bldr.{{$private}}
	pvt.rt = rt
	pvt.rx = rx
	pvt.tx = tx

	go pvt.loop()
	return tx
}

// {{$rx}} contains the Rx sides of the mailboxes, for access from the
// {{.ActorTypeBase}} implementation.
type {{$rx}} struct {
	id uint64
	rt *thespian.Runtime

	stopChan <-chan struct{}
	superChan <-chan thespian.SuperEvent
	healthChan <-chan struct{}

	{{- range .Mailboxes }}
	{{ .ActorRxStructDecl }}
	{{- end }}
}

// supervise starts supervision of the actor identified by otherID.
// It is a shortcut to thespian.Runtime.Supervize.
func (rx *{{$rx}}) supervise(otherID uint64) {
	rx.rt.Supervise(rx.id, otherID)
}

// unsupervise stops supervision of the actor identified by otherID.
// It is a shortcut to thespian.Runtime.Unupervize.
func (rx *{{$rx}}) unsupervise(otherID uint64) {
	rx.rt.Unsupervise(rx.id, otherID)
}

// {{$tx}} is the public handle for {{.ActorTypeBase}} actors.
type {{$tx}} struct {
	// ID is the unique ID of this actor
	ID uint64
	stopChan chan<- struct{}
	{{- range .Mailboxes }}
	{{ .ActorTxStructDecl }}
	{{- end }}
}

// Stop sends a message to stop the actor.  This does not wait until
// the actor has stopped.
func (a *{{$tx}}) Stop() {
	select {
	case a.stopChan <- struct{}{}:
	default:
	}
}

{{- range .Mailboxes }}
{{ .ActorTxStructMethod }}
{{- end }}

func (a *{{$private}}) loop() {
	rx := a.rx
	defer func() {
		{{- range .Mailboxes }}
		{{ .ActorCleanupClause }}
		{{- end }}
		a.rt.ActorStopped(a.rx.id)
	}()
	a.handleStart()
	for {
		select {
		case <-rx.healthChan:
			// nothing to do
		case ev := <-rx.superChan:
			a.handleSuperEvent(ev)
		case <-rx.stopChan:
			a.handleStop()
			return

		{{- range .Mailboxes }}
		{{ .ActorLoopCase }}
		{{- end }}
		}
	}
}
`), g)
}
