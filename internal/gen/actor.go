package gen

import (
	"sort"
	"text/template"
)

var (
	actorTemplate *template.Template
)

type ActorGenerator struct {
	ThisPackage string
	ThespianPkg string
	Name        string
	Mailboxes   []MailboxGenerator
}

func NewActorGenerator(pkg, name string, yml ActorYml) *ActorGenerator {
	gen := &ActorGenerator{
		ThisPackage: pkg,
		ThespianPkg: thespianPackage,
		Name:        name,
		Mailboxes:   nil,
	}

	// generate a stable order for mailbox fields
	mbFields := []string{}
	for fieldName := range yml.Mailboxes {
		mbFields = append(mbFields, fieldName)
	}
	sort.Strings(mbFields)

	for _, fieldName := range mbFields {
		actorMailboxYml := yml.Mailboxes[fieldName]
		gen.Mailboxes = append(gen.Mailboxes,
			NewMailboxGeneratorForActor(pkg, name, fieldName, actorMailboxYml))
	}

	return gen
}

func (g *ActorGenerator) GenerateGo(out *formatter) {
	out.executeTemplate(getTemplate(
		"actor_gen", `
// code generated by thespian; DO NOT EDIT

package {{.ThisPackage}}

import "{{.ThespianPkg}}"

// --- {{public .Name}}

// {{public .Name}} is the public handle for {{private .Name}} actors.
type {{public .Name}} struct {
	stopChan chan<- struct{}
	{{- range .Mailboxes }}
	{{ .ActorPublicStructDecl }}
	{{- end }}
}

// Stop sends a message to stop the actor.  This does not wait until
// the actor has stopped.
func (a *{{public .Name}}) Stop() {
	select {
	case a.stopChan <- struct{}{}:
	default:
	}
}

{{- range .Mailboxes }}
{{ .ActorPublicStructMethod }}
{{- end }}

// --- {{private .Name}}

func (a {{private .Name}}) spawn(rt *thespian.Runtime) *{{public .Name}} {
	rt.Register(&a.ActorBase)
	// TODO: these should be in a builder of some sort
	{{- range .Mailboxes }}
	{{ .ActorSpawnSetupClause }}
	{{- end }}

	{{- range .Mailboxes }}
	{{ .ActorSpawnRxAssignmentClause }}
	{{- end }}

	handle := &{{public .Name}}{
		stopChan: a.StopChan,
		{{- range .Mailboxes }}
		{{ .ActorSpawnHandleInitializer }}
		{{- end }}
	}
	go a.loop()
	return handle
}

func (a *{{private .Name}}) loop() {
	defer func() {
		a.cleanup()
	}()
	a.HandleStart()
	for {
		select {
		case <-a.HealthChan:
			// nothing to do
		case <-a.StopChan:
			a.HandleStop()
			return

		{{- range .Mailboxes }}
		{{ .ActorLoopCase }}
		{{- end }}
		}
	}
}

func (a *{{private .Name}}) cleanup() {
	{{- range .Mailboxes }}
	{{ .ActorCleanupClause }}
	{{- end }}
	a.Runtime.ActorStopped(&a.ActorBase)
}
`), g)
}
