// code generated by thespian; DO NOT EDIT

package gentest

import (
	"github.com/djmitche/thespian"
)

// ConcatenatorBuilder is used to buidl new Concatenator actors.
type ConcatenatorBuilder struct {
	concatenator
	input  StringMailbox
	output StringChanMailbox
}

func (bldr ConcatenatorBuilder) spawn(rt *thespian.Runtime) *ConcatenatorTx {
	reg := rt.Register()
	bldr.input.ApplyDefaults()
	bldr.output.ApplyDefaults()

	rx := &ConcatenatorRx{
		id:         reg.ID,
		stopChan:   reg.StopChan,
		healthChan: reg.HealthChan,
		input:      bldr.input.Rx(),
		output:     bldr.output.Rx(),
	}

	tx := &ConcatenatorTx{
		stopChan: reg.StopChan,
		input:    bldr.input.Tx(),
		output:   bldr.output.Tx(),
	}

	// copy to a new concatenator instance
	pvt := bldr.concatenator
	pvt.rt = rt
	pvt.rx = rx
	pvt.tx = tx

	go pvt.loop()
	return tx
}

// ConcatenatorRx contains the Rx sides of the mailboxes, for access from the
// Concatenator implementation.
type ConcatenatorRx struct {
	id         uint64
	stopChan   <-chan struct{}
	healthChan <-chan struct{}
	input      StringRx
	output     StringChanRx
}

// ConcatenatorTx is the public handle for Concatenator actors.
type ConcatenatorTx struct {
	stopChan chan<- struct{}
	input    StringTx
	output   StringChanTx
}

// Stop sends a message to stop the actor.  This does not wait until
// the actor has stopped.
func (a *ConcatenatorTx) Stop() {
	select {
	case a.stopChan <- struct{}{}:
	default:
	}
}

// Input sends to the actor's input mailbox.
func (tx *ConcatenatorTx) Input(m string) {
	tx.input.C <- m
}

// Output sends to the actor's output mailbox.
func (tx *ConcatenatorTx) Output(m chan<- string) {
	tx.output.C <- m
}

func (a *concatenator) loop() {
	rx := a.rx
	defer func() {

		a.rt.ActorStopped(a.rx.id)
	}()
	a.handleStart()
	for {
		select {
		case <-rx.healthChan: // TODO
			// nothing to do
		case <-rx.stopChan:
			a.handleStop()
			return
		case m := <-rx.input.C:
			a.handleInput(m)
		case m := <-rx.output.C:
			a.handleOutput(m)
		}
	}
}
